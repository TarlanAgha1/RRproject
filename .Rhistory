"tibble" = "3.2.1"
)
#check_and_install <- function(package, version) {
#  if (!require(package, character.only = TRUE)) {
#    package_version_install <- paste0(package, "@", version)
#    remotes::install_version(package_version_install)
#  }
#}
mapply(check_and_install, names(packages_version), packages_version)
```
#install.packages("remotes")
#library(remotes)
packages_version <- c(
"readr" = "2.1.4",
"dplyr" = "1.1.2",
"ggplot2" = "3.4.2",
"fastDummies" = "1.7.3",
"rpart" = "4.1.23",
"caret" = "6.0.94",
"rpart.plot" = "3.1.2",
"pROC" = "1.18.5",
"corrplot" = "0.92",
"RColorBrewer" = "1.1.3",
"tibble" = "3.2.1"
)
#check_and_install <- function(package, version) {
#  if (!require(package, character.only = TRUE)) {
#    package_version_install <- paste0(package, "@", version)
#    remotes::install_version(package_version_install)
#  }
#}
mapply(check_and_install, names(packages_version), packages_version)
```
#install.packages("remotes")
#library(remotes)
packages_version <- c(
"readr" = "2.1.4",
"dplyr" = "1.1.2",
"ggplot2" = "3.4.2",
"fastDummies" = "1.7.3",
"rpart" = "4.1.23",
"caret" = "6.0.94",
"rpart.plot" = "3.1.2",
"pROC" = "1.18.5",
"corrplot" = "0.92",
"RColorBrewer" = "1.1.3",
"tibble" = "3.2.1"
)
check_and_install <- function(package, version) {
if (!require(package, character.only = TRUE)) {
package_version_install <- paste0(package, "@", version)
remotes::install_version(package_version_install)
}
}
mapply(check_and_install, names(packages_version), packages_version)
```
#install.packages("remotes")
#library(remotes)
packages_version <- c(
"readr" = "2.1.4",
"dplyr" = "1.1.2",
"ggplot2" = "3.4.2",
"fastDummies" = "1.7.3",
"rpart" = "4.1.23",
"caret" = "6.0.94",
"rpart.plot" = "3.1.2",
"pROC" = "1.18.5",
"corrplot" = "0.92",
"RColorBrewer" = "1.1.3",
"tibble" = "3.2.1")
check_and_install <- function(package, version) {
if (!require(package, character.only = TRUE)) {
package_version_install <- paste0(package, "@", version)
remotes::install_version(package_version_install)
}
}
mapply(check_and_install, names(packages_version), packages_version)
```
#install.packages("remotes")
#library(remotes)
packages_version <- c(
"readr" = "2.1.4",
"dplyr" = "1.1.2",
"ggplot2" = "3.4.2",
"fastDummies" = "1.7.3",
"rpart" = "4.1.23",
"caret" = "6.0.94",
"rpart.plot" = "3.1.2",
"pROC" = "1.18.5",
"corrplot" = "0.92",
"RColorBrewer" = "1.1.3",
"tibble" = "3.2.1")
check_and_install <- function(package, version) {
if (!require(package, character.only = TRUE)) {
package_version_install <- paste0(package, "@", version)
remotes::install_version(package_version_install)
}
}
mapply(check_and_install, names(packages_version), packages_version)
#install.packages("remotes")
#library(remotes)
packages_version <- c(
"readr" = "2.1.4",
"dplyr" = "1.1.2",
"ggplot2" = "3.4.2",
"fastDummies" = "1.7.3",
"rpart" = "4.1.23",
"caret" = "6.0.94",
"rpart.plot" = "3.1.2",
"pROC" = "1.18.5",
"corrplot" = "0.92",
"RColorBrewer" = "1.1.3",
"tibble" = "3.2.1")
check_and_install <- function(package, version) {
if (!require(package, character.only = TRUE)) {
package_version_install <- paste0(package, "@", version)
remotes::install_version(package_version_install)
}
}
mapply(check_and_install, names(packages_version), packages_version)
url<-"https://raw.githubusercontent.com/WojciechMisiura/RRproject/main/bank.csv"
bank<-read_csv(url)
bank %>% summarize(across(everything(), ~sum(is.na(.))))
summary(bank)
ggplot(bank, aes(y = age)) +
geom_boxplot() +
theme_minimal() +
labs(title = "Boxplot for 'age'")
ggplot(bank, aes(x = age)) +
geom_histogram(bins = 100, fill = "blue", color = "black") +
labs(title = "Distribution of Age") +
theme_minimal()
ggplot(bank, aes(y = duration)) +
geom_boxplot() +
theme_minimal() +
labs(title = "Boxplot for 'duration'")
ggplot(bank, aes(x = duration)) +
geom_histogram(bins = 100, fill = "blue", color = "black") +
labs(title = "Distribution of Duration") +
theme_minimal()
bank_data <- bank
jobs <- c('management', 'blue-collar', 'technician', 'admin.', 'services',
'retired', 'self-employed', 'student', 'unemployed', 'entrepreneur',
=======
jobs <- c('management', 'blue-collar', 'technician', 'admin.', 'services',
'retired', 'self-employed', 'student', 'unemployed', 'entrepreneur',
jobs <- c('management', 'blue-collar', 'technician', 'admin.', 'services',
'retired', 'self-employed', 'student', 'unemployed', 'entrepreneur', )
jobs <- c('management', 'blue-collar', 'technician', 'admin.', 'services',
'retired', 'self-employed', 'student', 'unemployed', 'entrepreneur')
# Create a boxplot for 'age'
g_age <- ggplot(bank, aes(x = factor(0), y = age)) +
geom_boxplot() +
labs(x = NULL, y = "Age") +
theme(axis.title.x = element_blank())
g_age
# Create a distribution plot for 'age'
g_age_dist <- ggplot(bank, aes(x = age)) +
geom_histogram(bins = 100, fill = "blue", color = "black") +
ggtitle("Distribution of Age")
g_age_dist
# Create a boxplot for 'duration'
g_duration <- ggplot(bank, aes(x = factor(0), y = duration)) +
geom_boxplot() +
labs(x = NULL, y = "Duration") +
theme(axis.title.x = element_blank())
g_duration
# Create a distribution plot for 'duration'
g_duration_dist <- ggplot(bank, aes(x = duration)) +
geom_histogram(bins = 100, fill = "red", color = "black") +
ggtitle("Distribution of Duration")
g_duration_dist
# Copy data for processing
bank_data <- bank
# Count of people who made a deposit by job category
jobs <- c('management', 'blue-collar', 'technician', 'admin.', 'services',
'retired', 'self-employed', 'student', 'unemployed', 'entrepreneur',
>>>>>>> dbe50508f6d28778d5c49fd003ce381ed04d74ed
# Copy data for processing
bank_data <- bank
# Count of people who made a deposit by job category
jobs <- c('management', 'blue-collar', 'technician', 'admin.', 'services',
'retired', 'self-employed', 'student', 'unemployed', 'entrepreneur','housemaid', 'unknown')
for (j in jobs) {
count <- sum(bank_data$deposit == "yes" & bank_data$job == j)
cat(sprintf("%-15s : %5d\n", j, count))}
table(bank_data$job)
bank_data$job[bank_data$job %in% c('management', 'admin.')] <- 'white-collar'
bank_data$job[bank_data$job %in% c('services', 'housemaid')] <- 'pink-collar'
bank_data$job[bank_data$job %in% c('retired', 'student', 'unemployed', 'unknown')] <- 'other'
table(bank_data$job)
bank_data$poutcome <- as.character(bank_data$poutcome)
bank_data$poutcome[bank_data$poutcome == "other"] <- "unknown"
table(bank_data$poutcome)
bank_data <- select(bank_data, -contact)
bank_data$default_cat <- as.integer(bank_data$default == "yes")
bank_data$housing_cat <- as.integer(bank_data$housing == "yes")
bank_data$loan_cat <- as.integer(bank_data$loan == "yes")
bank_data <- select(bank_data, -c(default, housing, loan))
bank_data <- select(bank_data, -c(month, day))
bank_data$deposit_cat <- as.integer(bank_data$deposit == "yes")
bank_data <- select(bank_data, -deposit)
cat("Customers that have not been contacted before:", sum(bank_data$pdays == -1), "\n")
cat("Maximum values on pdays:", max(bank_data$pdays), "\n")
bank_data$pdays[bank_data$pdays == -1] <- 10000
bank_data$recent_pdays <- ifelse(bank_data$pdays > 0, 1/bank_data$pdays, 1/bank_data$pdays)
bank_data <- select(bank_data, -pdays)
tail(bank_data)
bank_with_dummies <- dummy_cols(bank_data, select_columns = c('job', 'marital', 'education', 'poutcome'),
remove_selected_columns = TRUE)
head(bank_with_dummies)
print(dim(bank_with_dummies))
summary(bank_with_dummies)
ggplot(bank_with_dummies, aes(x = age, y = balance)) +
geom_point(alpha = 0.5) +
labs(title = "Scatterplot of Age vs. Balance",
subtitle = "Across all ages, majority of people have savings of less than 20000",
x = "Age", y = "Balance") +
theme_minimal()
ggplot(bank_with_dummies, aes(x = duration)) +
geom_histogram(data = subset(bank_with_dummies, poutcome_success == 1), fill = "blue", bins = 30) +
labs(title = "Histogram of Duration for 'poutcome_success'",
x = "Duration", y = "Count") +
theme_minimal()
bank_with_dummies %>%
filter(deposit_cat == 1) %>%
summary()
sum(bank_with_dummies$deposit_cat == 1 & bank_with_dummies$loan_cat == 1 & bank_with_dummies$housing_cat == 1)
sum(bank_with_dummies$deposit_cat == 1 & bank_with_dummies$default_cat == 1)
ggplot(data = bank_data, aes(x = job, y = deposit_cat, fill = job)) +
geom_bar(stat = "summary", fun = mean) +
labs(title = "Average Deposit Category by Job", x = "Job Category", y = "Average Deposit Category") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot(data = bank_data, aes(x = poutcome, y = duration, fill = poutcome)) +
geom_bar(stat = "summary", fun = mean) +
labs(title = "Average Duration by Outcome", x = "Outcome", y = "Average Duration") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
bankcl <- bank_with_dummies
corr <- cor(bankcl, use = "complete.obs")
print(corr)
corrplot(corr, method = "color", type = "upper", order = "hclust",
tl.col = "black", tl.srt = 45,
col = colorRampPalette(c(brewer.pal(10, "RdBu")[10:1]))(200),
title = "Heatmap of Correlation Matrix",
cl.lim = c(-0.3, 0.3))
set.seed(50)
label <- bankcl$deposit_cat
data_drop_deposit <- bankcl[, !names(bankcl) %in% 'deposit_cat']
index_train <- createDataPartition(label, p = 0.8, list = FALSE)
data_train <- data_drop_deposit[index_train, ]
label_train <- label[index_train]
data_test <- data_drop_deposit[-index_train, ]
label_test <- label[-index_train]
train_and_evaluate <- function(depth) {
model <- rpart(formula = deposit_cat ~ ., data = bankcl, method = "class",
control = rpart.control(maxdepth = depth, usesurrogate = 0, xval = 10))
train_pred <- predict(model, data_train, type = "class")
test_pred <- predict(model, data_test, type = "class")
train_accuracy <- sum(train_pred == label_train) / length(label_train)
test_accuracy <- sum(test_pred == label_test) / length(label_test)
cat(sprintf("Depth %d: Training score: %f, Testing score: %f\n", depth, train_accuracy, test_accuracy))
}
for (depth in c(1, 2, 3, 4, 6)) {
train_and_evaluate(depth)
}
train_and_evaluate <- function(depth) {
model <- rpart(formula = deposit_cat ~ ., data = bankcl, method = "class",
control = rpart.control(maxdepth = depth, usesurrogate = 0, xval = 10))
train_pred <- predict(model, data_train, type = "class")
test_pred <- predict(model, data_test, type = "class")
train_accuracy <- sum(train_pred == label_train) / length(label_train)
test_accuracy <- sum(test_pred == label_test) / length(label_test)
cat(sprintf("Depth %d: Training score: %f, Testing score: %f\n", depth, train_accuracy, test_accuracy))
}
for (depth in c(1, 2, 3, 4, 6)) {
train_and_evaluate(depth)
}
scores <- list()
scores$`2` <- c(train = dt2_score_train, test = dt2_score_test)
scores <- list()
scores$`2` <- c(train = dt2_score_train, test = dt2_score_test)
train_and_evaluate <- function(depth) {
model <- rpart(formula = deposit_cat ~ ., data = bankcl, method = "class",
control = rpart.control(maxdepth = depth, usesurrogate = 0, xval = 10))
train_pred <- predict(model, data_train, type = "class")
test_pred <- predict(model, data_test, type = "class")
train_accuracy <- sum(train_pred == label_train) / length(label_train)
test_accuracy <- sum(test_pred == label_test) / length(label_test)
cat(sprintf("Depth %d: Training score: %f, Testing score: %f\n", depth, train_accuracy, test_accuracy))
return(c(train = train_accuracy, test = test_accuracy))
}
scores <- list()
depth_levels <- c(1, 2, 3, 4, 6)
names(depth_levels) <- c("max", "2", "3", "4", "6")
for (depth in depth_levels) {
scores[[as.character(depth)]] <- train_and_evaluate(depth)
}
cat(sprintf('%-10s %-20s %-20s\n', 'depth', 'Training score', 'Testing score'))
cat(sprintf('%-10s %-20s %-20s\n', '-----', '--------------', '-------------'))
for (depth in c("2", "3", "4", "6", "max")) {
cat(sprintf('%-1s %-25.2f %-20.2f\n', depth, scores[[depth]]$train, scores[[depth]]$test))
}
scores <- list()
# Assuming depth_levels are defined or use directly c(1, 2, 3, 4, 6)
depth_levels <- c(1, 2, 3, 4, 6)
names(depth_levels) <- c("max", "2", "3", "4", "6") # Assure names are correct for your depths
for (depth in depth_levels) {
result <- train_and_evaluate(depth)
# Making sure the result is stored as a list with named elements
scores[[as.character(depth)]] <- list(train = result[1], test = result[2])
}
# Display the scores
cat(sprintf('%-10s %-20s %-20s\n', 'depth', 'Training score', 'Testing score'))
cat(sprintf('%-10s %-20s %-20s\n', '-----', '--------------', '-------------'))
for (depth in c("2", "3", "4", "6", "max")) {
cat(sprintf('%-1s %-25.2f %-20.2f\n', depth, scores[[depth]]$train, scores[[depth]]$test))
}
train_and_evaluate <- function(depth) {
model <- rpart(formula = deposit_cat ~ ., data = bankcl, method = "class",
control = rpart.control(maxdepth = depth, usesurrogate = 0, xval = 10))
train_pred <- predict(model, data_train, type = "class")
test_pred <- predict(model, data_test, type = "class")
train_accuracy <- sum(train_pred == label_train) / length(label_train)
test_accuracy <- sum(test_pred == label_test) / length(label_test)
cat(sprintf("Depth %d: Training score: %f, Testing score: %f\n", depth, train_accuracy, test_accuracy))
return(c(train = train_accuracy, test = test_accuracy)) # Ensure it returns as a named vector which can be converted to a list
}
train_and_evaluate <- function(depth) {
model <- rpart(formula = deposit_cat ~ ., data = bankcl, method = "class",
control = rpart.control(maxdepth = depth, usesurrogate = 0, xval = 10))
train_pred <- predict(model, data_train, type = "class")
test_pred <- predict(model, data_test, type = "class")
train_accuracy <- sum(train_pred == label_train) / length(label_train)
test_accuracy <- sum(test_pred == label_test) / length(label_test)
cat(sprintf("Depth %d: Training score: %f, Testing score: %f\n", depth, train_accuracy, test_accuracy))
return(c(train = train_accuracy, test = test_accuracy)) # Ensure it returns as a named vector which can be converted to a list
}
scores <- list()
# Assuming depth_levels are defined or use directly c(1, 2, 3, 4, 6)
depth_levels <- c(1, 2, 3, 4, 6)
names(depth_levels) <- c("max", "2", "3", "4", "6") # Assure names are correct for your depths
for (depth in depth_levels) {
result <- train_and_evaluate(depth)
# Making sure the result is stored as a list with named elements
scores[[as.character(depth)]] <- list(train = result[1], test = result[2])
}
# Display the scores
cat(sprintf('%-10s %-20s %-20s\n', 'depth', 'Training score', 'Testing score'))
cat(sprintf('%-10s %-20s %-20s\n', '-----', '--------------', '-------------'))
for (depth in c("2", "3", "4", "6", "max")) {
cat(sprintf('%-1s %-25.2f %-20.2f\n', depth, scores[[depth]]$train, scores[[depth]]$test))
}
dt2 <- rpart(deposit_cat ~ ., data = bankcl, method = "class", control = rpart.control(maxdepth = 2))
rpart.plot(dt2, main = "Decision Tree for Depth 2", extra = 106)
features <- colnames(data_drop_deposite)
dt2 <- rpart(label_train ~ ., data = data_train, method = "class", control = rpart.control(maxdepth = 2))
fi <- rpart::importance(dt2)
install.packages('rpart')
install.packages('rpart')
install.packages("rpart")
install.packages("rpart")
install.packages("rpart")
install.packages("rpart")
library('rpart')
sessionInfo()
#install.packages("remotes")
#library(remotes)
packages_version <- c(
"readr" = "2.1.4",
"dplyr" = "1.1.2",
"ggplot2" = "3.4.2",
"fastDummies" = "1.7.3",
"rpart" = "4.1.23",
"caret" = "6.0.94",
"rpart.plot" = "3.1.2",
"pROC" = "1.18.5",
"corrplot" = "0.92",
"RColorBrewer" = "1.1.3",
"tibble" = "3.2.1",
"rpart" = "4.1.23")
check_and_install <- function(package, version) {
if (!require(package, character.only = TRUE)) {
package_version_install <- paste0(package, "@", version)
remotes::install_version(package_version_install)
}
}
mapply(check_and_install, names(packages_version), packages_version)
dt2 <- rpart(label_train ~ ., data = data_train, method = "class", control = rpart.control(maxdepth = 2))
fi <- rpart::importance(dt2)
dt2 <- rpart(label_train ~ ., data = data_train, method = "class", control = rpart.control(maxdepth = 2))
fi <- importance(dt2)
dt2 <- rpart(label_train ~ ., data = data_train, method = "class", control = rpart.control(maxdepth = 2))
fi <- dt2$variable.importance
features <- names(fi)
l <- length(features)
for (i in 1:l) {
cat(spr
dt2 <- rpart(label_train ~ ., data = data_train, method = "class", control = rpart.control(maxdepth = 2))
fi <- dt2$variable.importance
features <- names(fi)
l <- length(features)
for (i in 1:l) {
cat(sprintf('%-20s %3f\n', features[i], fi[i]))
}
set.seed(50)
label <- bankcl$deposit_cat
data_drop_deposit <- bankcl[, !names(bankcl) %in% 'deposit_cat']
index_train <- createDataPartition(label, p = 0.8, list = FALSE)
data_train <- data_drop_deposit[index_train, ]
label_train <- label[index_train]
data_test <- data_drop_deposit[-index_train, ]
label_test <- label[-index_train]
train_and_evaluate <- function(depth) {
model <- rpart(formula = deposit_cat ~ ., data = bankcl, method = "class",
control = rpart.control(maxdepth = depth, usesurrogate = 0, xval = 10))
train_pred <- predict(model, data_train, type = "class")
test_pred <- predict(model, data_test, type = "class")
train_accuracy <- sum(train_pred == label_train) / length(label_train)
test_accuracy <- sum(test_pred == label_test) / length(label_test)
cat(sprintf("Depth %d: Training score: %f, Testing score: %f\n", depth, train_accuracy, test_accuracy))
return(c(train = train_accuracy, test = test_accuracy))
}
scores <- list()
depth_levels <- c(1, 2, 3, 4, 6)
names(depth_levels) <- c("max", "2", "3", "4", "6")
for (depth in depth_levels) {
result <- train_and_evaluate(depth)
scores[[as.character(depth)]] <- list(train = result[1], test = result[2])
}
cat(sprintf('%-10s %-20s %-20s\n', 'depth', 'Training score', 'Testing score'))
cat(sprintf('%-10s %-20s %-20s\n', '-----', '--------------', '-------------'))
for (depth in c("2", "3", "4", "6", "max")) {
cat(sprintf('%-1s %-25.2f %-20.2f\n', depth, scores[[depth]]$train, scores[[depth]]$test))
}
dt2 <- rpart(label_train ~ ., data = data_train, method = "class", control = rpart.control(maxdepth = 2))
fi <- dt2$variable.importance
features <- names(fi)
l <- length(features)
for (i in 1:l) {
cat(sprintf('%-20s %3f\n', features[i], fi[i]))
}
cat(sprintf("Mean duration   : %f\n", mean(data_drop_deposite$duration, na.rm = TRUE)))
set.seed(50)
label <- bankcl$deposit_cat
data_drop_deposit <- bankcl[, !names(bankcl) %in% 'deposit_cat']
index_train <- createDataPartition(label, p = 0.8, list = FALSE)
data_train <- data_drop_deposit[index_train, ]
label_train <- label[index_train]
data_test <- data_drop_deposit[-index_train, ]
label_test <- label[-index_train]
cat(sprintf("Mean duration   : %f\n", mean(data_drop_deposite$duration, na.rm = TRUE)))
set.seed(50)
label <- bankcl$deposit_cat
data_drop_deposite <- bankcl[, !names(bankcl) %in% 'deposit_cat']
index_train <- createDataPartition(label, p = 0.8, list = FALSE)
data_train <- data_drop_deposite[index_train, ]
label_train <- label[index_train]
data_test <- data_drop_deposite[-index_train, ]
label_test <- label[-index_train]
cat(sprintf("Mean duration   : %f\n", mean(data_drop_deposite$duration, na.rm = TRUE)))
cat(sprintf("Maximum duration: %d\n", max(data_drop_deposite$duration, na.rm = TRUE)))
cat(sprintf("Minimum duration: %d\n", min(data_drop_deposite$duration, na.rm = TRUE)))
# Example setup for new data for prediction (ensure all features are correctly named and included)
new_data_371 <- data.frame(matrix(0, nrow = 1, ncol = length(names(data_drop_deposite))))
names(new_data_371) <- names(data_drop_deposite)
new_data_371$duration <- 371  # Set duration for prediction
new_data_3881 <- data.frame(matrix(0, nrow = 1, ncol = length(names(data_drop_deposite))))
names(new_data_3881) <- names(data_drop_deposite)
new_data_3881$duration <- 3881  # Set duration for prediction
# Predict probabilities and class
# Probability predictions
probabilities_371 <- predict(dt2, new_data_371, type = "prob")
probabilities_3881 <- predict(dt2, new_data_3881, type = "prob")
# Class predictions
class_371 <- predict(dt2, new_data_371, type = "class")
class_3881 <- predict(dt2, new_data_3881, type = "class")
# Output results
cat("Probabilities with duration 371 sec:\n")
print(probabilities_371)
cat("Predicted class with duration 371 sec:\n")
print(class_371)
cat("Probabilities with duration 3881 sec:\n")
print(probabilities_3881)
cat("Predicted class with duration 3881 sec:\n")
print(class_3881)
specific_row <- data_drop_deposite[986, ]
probability_prediction <- predict(dt2, specific_row, type = "prob")
print(probability_prediction)
preds <- predict(dt2, data_test, type = "class")
# Calculate accuracy
accuracy <- confusionMatrix(preds, label_test)$overall['Accuracy']
preds <- predict(dt2, data_test, type = "class")
levels_set <- union(levels(factor(label_test)), levels(factor(preds)))
preds_factor <- factor(preds, levels = levels_set)
label_test_factor <- factor(label_test, levels = levels_set)
# Now calculate accuracy using confusionMatrix
library(caret)
accuracy_matrix <- confusionMatrix(preds_factor, label_test_factor)
accuracy <- accuracy_matrix$overall['Accuracy']
# Print the accuracy
cat("\nAccuracy score: \n", accuracy)
probs <- predict(dt2, data_test, type = "prob")
# Since predict gives probabilities for all classes, select the probability of the positive class
# Assuming the positive class is the second column
positive_probs <- probs[, 2]
# Calculate the AUC metric
library(pROC)  # Load pROC for ROC AUC calculation
auc_value <- roc(label_test, positive_probs)$auc
cat("\nArea Under Curve: \n", auc_value)
sessionInfo()
